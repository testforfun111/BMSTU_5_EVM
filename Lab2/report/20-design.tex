\chapter*{Эксперимент №1: Исследования расслоения динамической памяти}
\addcontentsline{toc}{chapter}{Эксперимент №1: Исследования расслоения динамической памяти}

\subsection*{Цель эксперимента}
Определение способа трансляции физического адреса, используемого при обращении к динамической памяти. 

\subsection*{Описание проблемы}
В связи с конструктивной неоднородностью оперативной памяти, обращение к последовательно расположенным данным требует различного времени. В связи с этим, для создания эффективных программ необходимо учитывать расслоение памяти, характеризуемое способом трансляции физического адреса.

\subsection*{Исходные данные}
Размер линейки кэш-памяти верхнего уровня; объем физическойь памяти.


\subsection*{Результаты эксперимента}
На рисунке \ref{img:Lab2_1} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Максимальное расстояния между	читаемыми блоками (К) = 32;
	\item Шаг увеличения расстояния между читаемыми 4-х байтовыми ячейками (Б) = 64;
	\item Размер массива (М) = 2.
\end{itemize}

\img{80mm}{Lab2_1}{Эксперимет №1, результат}

\subsection*{Вывод}
Оперативная память неоднородна, и для обращения к последовательно расположенными данным может потребоваться различное количество времени. Поэтому, при создании программ необходимо учитывать расслоение памяти при обработке данных.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №2: Сравнение эффективности ссылочных и векторных структур}
\addcontentsline{toc}{chapter}{Эксперимент №2: Сравнение эффективности ссылочных и векторных структур}

\subsection*{Цель эксперимента}
Оценка влияния зависимости команд по данным на эффективность вычислений. 

\subsection*{Описание проблемы}
Обработка зависимых данных происходит в тех случаях, когда результат работы одной команды используется в качестве адреса операнда другой. При программировании на языках высокого уровня такими операндами являются указатели, активно используемые при обработке ссылочных структур данных: списков, деревьев, графов. Обработка данных структур процессорами с длинными конвейерами команд приводит к заметному увеличению времени работы алгоритмов: адрес загружаемого операнда становится известным только после обработки предыдущей команды. В противоположность этому, обработка векторных структур, таких как массивы, позволяет эффективно использовать аппаратные возможности ЭВМ. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:lab2_2} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Количество элементов в списке (М) = 4;
	\item Максимальная фрагментации списка (К) = 128;
	\item Шаг увеличения фрагментации (К) = 4.
\end{itemize}

\img{90mm}{lab2_2}{Эксперимет №2}
\newpage

\subsection*{Вывод}
Вывод из полученных результатов можно сделать следующий: использовать структуры данных надо с учетом технологического фактора определенной задачи. Если решаемая задача продполагает возможность использования массива, то надо использовать его, особенно если использование списка не дает существенной разницы (особенно выиграша во времени).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №3: Исследование эффективности программной предвыборки}
\addcontentsline{toc}{chapter}{Эксперимент №3: Исследование эффективности программной предвыборки}

\subsection*{Цель эксперимента}
Выявление способов ускорения вычислений благодаря применению предвыборки данных. 

\subsection*{Исходные данные}
Cтепень ассоциативности и размер TLB данных.

\subsection*{Описание проблемы}
Обработка больших массивов информации сопряжена с открытием большого количества физических страниц памяти. При первом обращении к странице памяти наблюдается увеличенное время доступа к данным. Это связано с необходимостью преобразования логического адреса в физический адрес памяти, а также c открытием страницы динамической памяти и сохранения данных в кэш-памяти.

Преобразование выполняется на основе информации о использованных ранее страницах, содержащейся в TLB буфере процессора. Первое обращение к странице при отсутствии информации в TLB вызывает двойное обращение к оперативной памяти: сначала за информацией из таблицы страниц, а далее за востребованными данными. Предвыборка заключается в заблаговременном проведении всех указанных действий благодаря дополнительному запросу небольшого количества данных из оперативной памяти. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:lab2_3} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Шаг увеличения расстояния между читаемыми данными
(Б) = 512;
	\item Размер массива (К) = 64.
\end{itemize}

\img{90mm}{lab2_3}{Эксперимет №3}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:lab2_31}. Как видно на рисунке, обработка без загрузки таблицы страниц в TLB производилась в 3,0038393 раз дольше.

\img{90mm}{lab2_31}{Эксперимет №3, результат}

Красный график - чтение страниц последовательно из оперативной памяти. Зеленый график - чтение страниц, используя дополнительный цикл предвыборки, обеспечивающий своевременную загрузку информации в TLB данных.

Сокращение времени работы алгоритма, который использует предвыборку, происходит в том случае, когда информация о востребованных страницах помещается в TLB. 

Пики на красном графике происходят из-за того, что процессу неободимо преобразовать физический адрес в логический.

\subsection*{Вывод}
Используя предвыборку можно ускорить время работы программы почти в 3 раза за счет заблаговременной загрузки страниц в память.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №4: Исследование способов эффективного чтения оперативной памяти}
\addcontentsline{toc}{chapter}{Эксперимент №4: Исследование способов эффективного чтения оперативной памяти}

\subsection*{Цель эксперимента}
Исследование возможности ускорения вычислений благодаря использованию структур данных, оптимизирующих механизм чтения оперативной памяти.

\subsection*{Исходные данные}
Адресное расстояние между банками памяти, размер буфера чтения.

\subsection*{Описание проблемы}
При обработке информации, находящейся в нескольких страницах и банках оперативной памяти возникают задержки, связанные с необходимостью открытия и закрытия страниц DRAM памяти. При программировании на языках высокого уровня такая ситуация наблюдается при интенсивной обработке нескольких массивов данных или обработке многомерных массивов. При этом процессоры, в которых реализованы механизмы аппаратной предвыборки, часто не могут организовать эффективную загрузку данных. Кроме этого, объемы запрошенных данных оказываются заметно меньше размера пакета, передаваемого из оперативной памяти. Таким образом, эффективная обработка нескольких векторных структур данных без их дополнительной оптимизации не использует в должной степени возможности аппаратных ресурсов. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:lab2_4} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Размер массива (М) = 4;
	\item Количество потоков данных = 64.
\end{itemize}

\img{80mm}{lab2_4}{Эксперимет №4}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:lab2_41}. Как видно на рисунке, неоптимизированная структура обрабатывалась в 1,6 раз дольше.

\img{60mm}{lab2_41}{Эксперимет №4, результат}

Красный график показывает время или количество тактов работы алгоритма, использующего неоптимизированную структуру.

Зеленый график показывает время (или количество тактов) работы алгоритма с использованием оптимизированной структуры.

Оптимизация заключается в том, что струтура данных, ускоряющая обработку современным процессорам, пытается максимально исключить несвоевременную передачу данных, то есть передавть только лишь востребованную для вычислений инфорацию. Поэтому снижается количество открытий и закрытий страниц DRAM-памяти и обеспечивается параллельная обработка данных, а также выполнение операций загрузки и выгрузки.


\subsection*{Вывод}
Можно сделать вывод, что для ускорения работы алгоритмов, необходимо правильно упорядочить данные.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №5: Исследование конфликтов в кэш-памяти}
\addcontentsline{toc}{chapter}{Эксперимент №5: Исследование конфликтов в кэш-памяти}

\subsection*{Цель эксперимента}
Исследование влияния конфликтов кэш-памяти на эффективность вычислений.


\subsection*{Исходные данные}
Размер банка кэш-памяти данных первого и второго уровня, степень ассоциативности кэш-памяти первого и второго уровня, размер линейки кэшпамяти первого и второго уровня.

\subsection*{Описание проблемы}
Наборно-ассоциативная кэш-память состоит из линеек данных, организованных в несколько независимых банков. Выбор банка для каждой порции кэшируемых данных выполняется по ассоциативному принципу, т.е. из условия улучшения представительности выборки, в то время как целевая линейка в каждом из банков жестко определяется по младшей части физического адреса. Совокупность таких линеек всех банков принято называть набором. Таким образом, попытка читать данные из оперативной памяти с шагом, кратным размеру банка, приводит к их помещению в один и тот же набор.Если же количество запросов превосходит степень ассоциативности кэш-памяти, т.е. количество банков или количество линеек в наборе, то наблюдается постоянное вытеснение данных из кэш-памяти, причем больший ее объем остается незадействованным. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:lab2_5} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Размер банка кэш-памяти (К) = 4;
	\item Размер линейки кэш-памяти (б) = 64;
	\item Количество читаемых линеек = 256.
\end{itemize}

\img{80mm}{lab2_5}{Эксперимет №5}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:lab2_51}. Как видно на рисунке, чтение с конфликтами банков производилось в 14,24 раз дольше.

\img{60mm}{lab2_51}{Эксперимет №5, результат}
\newpage

Красный график показывает время или количество тактов работы процедуры, читающей данные с конфликтами в кэш-памяти. 

Зеленый график показывает время или количество тактов работы процедуры, не вызывающей конфликтов в кэш-памяти. Ось абсцисс отражает смещение читаемой ячейки от начала блока данных.

Красный график соответствует алгоритму, который построен таким образом, что чтение данных выполняеся с шагом, кратным размеру банка. Именно это и порождает постоянные конфликты в кэш-памяти.

Зеленый график соответсвует алгоритму, который оптимизируется размещение данных в кэш с помощью задания смещения востребованных данных на шаг, достаточный для выбора другого набора. (Шаг соответствует размеру линейки).

\subsection*{Вывод}
Можно сделать вывод, что использование кэш-памяти работа процессора ускоряется почти в 14 раз.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №6: Сравнение алгоритмов сортировки}
\addcontentsline{toc}{chapter}{Эксперимент №6: Сравнение алгоритмов сортировки}

\subsection*{Цель эксперимента}
Исследование способов эффективного использования памяти и выявление наиболее эффективных алгоритмов сортировки, применимых в вычислительных системах. 

\subsection*{Исходные данные}
Количество процессоров вычислительной системы, размер пакета, количество элементов в массиве, разрядность элементов массива.

\subsection*{Описание проблемы}
Существует несколько десятков алгоритмов сортировки. Их можно классифицировать по таким критериям, как: назначение (внутренняя и внешняя сортировки), вычислительная сложность (алгоритмы с вычислительными сложностями $O(n^2), O(n*log(n)), O(n), O(n/log(n))$), емкостная сложность (алгоритмы, требующие и не требующие дополнительного массива), возможность распараллеливания (не распараллеливаемые, ограниченно распараллеливаемые, полностью распараллеливаемые), принцип определения порядка (алгоритмы, использующие парные сравнения и не использующие парные сравнения).  

\subsubsection{Radix Sort}

Логика данной сортировки проста. Допустим, у нас есть массив из 10 чисел.

Сначала идет сортировка их по первому (старшему) разряду. Сортировка в таком случае выполняется с помощью сортировки подсчетом (count sort). Сложность — $O(n)$. 

В итоге получается 10 «корзин» — в которых старший разряд 0, 1, 2 и т.д.

Далее в каждой из корзин запускаем ту же процедуру, но только рассматриваем уже не старший разряд, а следующий за ним, и т.д.

Такие действия выполняется до последнего разряда.

\subsection*{Результаты эксперимента}
На рисунке \ref{img:lab2_6} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Количество 64-х разрядных элементов массивов (М) = 1;
	\item Шаг увеличения размера массива (К) = 32.
\end{itemize}

\img{80mm}{lab2_6}{Эксперимет №6}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:lab2_61}. Как видно на рисунке, QuickSort работал в 1.68 раз дольше Radix-Counting Sort, и QuickSort работал в 1.94 раз дольше Radix-Counting Sort, оптимизированного под 8-процессорную ЭВМ.

\img{60mm}{lab2_61}{Эксперимет №6, результат}
\newpage

Фиолетовый график показывает время или количество тактов работы алгоритма QuickSort. 

Красный график показывает время или количество тактов работы неоптимизированного алгоритма Radix-Counting. 

Зеленый график показывает время или количество тактов работы оптимизированного под 8-процессорную вычислительную систему алгоритма Radix-Counting.

\subsection*{Вывод}
Можно сделать вывод о том, что существует сортировка, работающая быстрее чем QuickSort, при этом, даже ее можно еще оптимизировать для более быстрой работы.

